#### 포인터를 사용하려면, 주소 구하기 연산자, 역참조 연산자가 필요하다. ####
____
- **주소구하기 연산자는 & 다음에 나오는 변수의 주소를 구한다.**
```c
int x = 10;
int *p = &x; // p는 x의 주소로 초기화 한다.
```

- **& 연산자는 l-value, 즉 변수에만 사용할 수 있다.**
```c
p = &123; // 상수에는 주소가 없으므로 컴파일 에러
p = &(x + 1); // (x + 1)은 l-value가 아니므로 컴파일 에러
p = &printf("hello"); // 함수 호출도 l -value가 아니므로 컴파일 에러
```

#### 포인터가 가리키는 변수에 접근하려면 역참조 연산자 * 를 사용한다. ####
____
- **포인터 앞에 * 를 쓰면 포인터가 가리키는 변수의 값을 읽어오거나 변경할 수 있다.**
```c
printf("%d", *p); // p가 가리키는 int형 변수의 값을 출력하라는 의미
*p = 20; // p가 가리키는 int형 변수에 20을 대입하라는 의미
```

- **역참조 연산자는 간접 참조(indirection) 연산자라고도 한다.**
```c
int x = 10;
*x = 30; // 일반 변수에는 *를 사용할 수 없으므로 컴파일 에러
*(x + 1) = 40; // 수식에는 *연산자를 사용할 수 없으므로 컴파일 에러
```

포인터의 사용
```c
# include <stdio.h>

int main(void)
{
	int x = 10;
	int *p = &x; // p는 x의 주소로 초기화 한다.

	printf(" x = %d\n", x);
	printf("&x = %p\n", &x); // &x는 주소값 이므로  %p로 출력

	printf(" p = %p\n", p);
	printf("*p = %d\n", *p); // *p는 int형 변수이므로 %d로 출력
	printf("&p = %p\n", &p); // 포인터도 변수이므로 주소가 있다.

	*p = 20; // x = 20;으로 수행된다.

	printf("*p = %d\n", *p) // printf("*p = %d\n", x); 로 수행된다

	return 0;
}
/* 실행결과
x = 10
&x = 0117FA00
p = 0117FA00
*p = 10
&p = 0117F9F4
*p = 20
```